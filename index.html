<!DOCTYPE html>
<meta charset="utf-8">
<style>

   .land {
      fill: #999;
      stroke-opacity: 1;
   }

   .graticule {
      fill: none;
      stroke: black;
      stroke-width:.5;
      opacity:.2;
   }

   .labels {
      font: 8px sans-serif;
      fill: black;
      opacity: .5;

      display:none;
   }

   .noclicks {
      pointer-events:none;
   }

   .heat { 
   }
   .temperature { 
      opacity: 0.5;
   }

   .flows {
      //stroke-linejoin: round;
   }
   .currents {
      //stroke-linejoin: round;
   }

</style>

<body>

<p>
  <label for="nPeriod" 
         style="display: inline-block; width: 240px; text-align: right">
         5d Time Period = <span id="nPeriod-value">â€¦</span>
  </label>
  <input type="range" min="1" max="72" id="nPeriod">
  // TODO button to stop / start the automatic transition
</p>

   <!--
   <script src="http://d3js.org/d3.v3.min.js"></script>
   <script src="http://d3js.org/queue.v1.min.js"></script>
   <script src="http://d3js.org/topojson.v0.min.js"></script>
   -->
   <script src="scripts/d3.v3.min.js"></script>
   <script src="scripts/queue.v1.min.js"></script>
   <script src="scripts/topojson.v0.min.js"></script>
   <script>

   d3.select(window)
   .on("mousemove", mousemove)
   .on("mouseup", mouseup);

   var zoom = d3.behavior.zoom()
   .scaleExtent([1, 2])
   .on("zoomstart", zoomStart)
   .on("zoom", zoomed)
   .on("zoomend", zoomEnd);

   var width = 1280,
   height = 720;

   var proj_zoom = [220, 660];
   var sky_zoom = [300, 900];
   var normed_zoom = 0.0;

   var proj = d3.geo.orthographic()
   .translate([width / 2, height / 2])
   .clipAngle(90)
   .scale(220);

   var sky = d3.geo.orthographic()
   .translate([width / 2, height / 2])
   .clipAngle(90)
   .scale(300);

   var path = d3.geo.path().projection(proj).pointRadius(2);

   var swoosh = d3.svg.line()
   .x(function(d) { return d[0] })
   .y(function(d) { return d[1] })
   .interpolate("cardinal")
   .tension(.0);

   var flowLines = [],
   tempspots = [],
   celcius= [],
   flow = [];

   var time_idx = 0;

   var svg = d3.select("body").append("svg")
   .attr("width", width)
   .attr("height", height)
   .on("mousedown", mousedown)
   .call(zoom);

queue()
   .defer(d3.json, "world-110m.json")
   //.defer(d3.json, "places.json")
   //.defer(d3.json, "data/2012_fifth_data.json")
   //.defer(d3.json, "data/2012_third_data.json")
   .defer(d3.json, "data/2012_25percent.json")
   .defer(d3.json, "data/temp_2p.json")
   //.defer(d3.json, "data/2012_10percent.ubjson") // looks like universal binary
   // does not work TODO load with d3.xhr?
   .await(ready);

   // places is now the flow data
   function ready(error, world, places, temp) {
      var ocean_fill = svg.append("defs").append("radialGradient")
         .attr("id", "ocean_fill")
         .attr("cx", "75%")
         .attr("cy", "25%");
      ocean_fill.append("stop").attr("offset", "5%").attr("stop-color", "#fff");
      ocean_fill.append("stop").attr("offset", "100%").attr("stop-color", "#0000dd");

      var globe_highlight = svg.append("defs").append("radialGradient")
         .attr("id", "globe_highlight")
         .attr("cx", "75%")
         .attr("cy", "25%");
      globe_highlight.append("stop")
         .attr("offset", "5%").attr("stop-color", "#ffd")
         .attr("stop-opacity","0.6");
      globe_highlight.append("stop")
         .attr("offset", "100%").attr("stop-color", "#ba9")
         .attr("stop-opacity","0.2");

      var globe_shading = svg.append("defs").append("radialGradient")
         .attr("id", "globe_shading")
         .attr("cx", "55%")
         .attr("cy", "45%");
      globe_shading.append("stop")
         .attr("offset","10%").attr("stop-color", "#fff")
         .attr("stop-opacity","0")
         globe_shading.append("stop")
         .attr("offset","100%").attr("stop-color", "#505962")
         .attr("stop-opacity","0.3")

      var drop_shadow = svg.append("defs").append("radialGradient")
         .attr("id", "drop_shadow")
         .attr("cx", "50%")
         .attr("cy", "50%");
      drop_shadow.append("stop")
         .attr("offset","20%").attr("stop-color", "#000")
         .attr("stop-opacity",".5")
         drop_shadow.append("stop")
         .attr("offset","100%").attr("stop-color", "#000")
         .attr("stop-opacity","0")  

      svg.append("ellipse")
         .attr("cx", width / 2).attr("cy", height * 0.8)
         .attr("rx", proj.scale()*.90)
         .attr("ry", proj.scale()*.25)
         .attr("class", "noclicks")
         .style("fill", "url(#drop_shadow)");

      svg.append("circle")
         .attr("cx", width / 2).attr("cy", height / 2)
         .attr("r", proj.scale())
         .attr("class", "noclicks")
         .style("fill", "url(#ocean_fill)");


      // TODO could do something like above where it
      // draw lines between adjacent coordinates
      // TODO way to select which year of data to display?
         places.features.forEach(function(a) {
            flow.push({
               center: a.geometry.coordinates,
               zonal: a.geometry.uf,
               medial: a.geometry.vf
               });
         });
         temp.features.forEach(function(a) {
            celcius.push({
               center: a.geometry.coordinates,
               temp: a.geometry.temp
               });
         });

      flowLines = make_flows(flow); // make global
      tempspots = make_temps(celcius);
      time_idx = 1;
      tempspots = make_temps(celcius);
      time_idx = 0;

      svg.append("defs").append("marker")
      	.attr("id", "arrowHead")
         .attr("viewBox", "0 0 10 10") 
      	.attr("refX", 8)
      	.attr("refY", 5)
      	.attr("orient", "auto")
         .attr("markerWidth", 2.0*normed_zoom)
         .attr("markerHeight", 1.8*normed_zoom) 
      	.append("polyline")
         .attr("points", "0,0 10,5 0,10 1,5")	  
         // TODO check arrow opacity, color
         //.selectAll("path").data(flowLines)
         //.enter().append("path")
         //.style("stroke", function(d) { return d.options.color;});

      svg.append("g").attr("class","currents")
         .selectAll("path").data(flowLines)
         .enter().append("path")
         //.style("marker-end", "url(#arrowHead)")
         .attr("class","flows")
         .attr("d",path)
         .style("stroke", function(d) { return d.options.color;})
         .style("stroke-width", function(d) { return d.options.zoom;})
         .style("opacity", function(d) { return d.options.opacity;})
         //.style("fill", function(d) { return d.options.color;})

      svg.append("g").attr("class","heat")
         .selectAll("text").data(tempspots)
         .enter().append("path")
         .attr("class", "temperature")
         .attr("d", path)
         //.style("fill", function(d) { return d.options.color;})
         //.style("stroke", function(d) { return d.options.color;})
         //.style("stroke-width", function(d) { return d.options.zoom;})
         //.style("opacity", function(d) { return d.options.opacity;})

      svg.append("path")
         .datum(topojson.object(world, world.objects.land))
         .attr("class", "land noclicks")
         .attr("d", path);

      svg.append("circle")
         .attr("cx", width / 2).attr("cy", height / 2)
         .attr("r", proj.scale())
         .attr("class","noclicks")
         .style("fill", "url(#globe_highlight)");

      svg.append("circle")
         .attr("cx", width / 2).attr("cy", height / 2)
         .attr("r", proj.scale())
         .attr("class","noclicks")
         .style("fill", "url(#globe_shading)");
      refresh(0);

      (function transition() {
      d3.transition()
      .duration(500)
      .each("start", function() {
         time_idx += 1;

         d3.select("#nPeriod-value").text(time_idx%72);
         d3.select("#nPeriod").property("value", time_idx%72);
         
         refresh(1);
      })
      .transition()
      .each("end", transition);
      })();

}

function make_flows(locations) {
   //console.log("making flow for time "+time_idx+" "+normed_zoom);
      var z = normed_zoom * 5 + 2;
      flowLines = []; // global
      var idx = time_idx % 72;
      locations.forEach(function(e,i,a) {
         // temporary flow line indicators
         // should be normalized with width indicating strength of flow?
         var num = e.zonal.length;
         var mag = Math.sqrt(e.zonal[idx]*e.zonal[idx]
            + e.medial[idx]*e.medial[idx]); // total flow strength
         //var norm= Math.abs(e.zonal[idx]) + Math.abs(e.medial[idx]);

         // TODO input field for this threshold
         if (Math.abs(mag) > 0.05) {
            var uf = e.zonal[idx]; // / mag;
            var vf = e.medial[idx]; // / mag;

            var source = [e.center[0]+uf, e.center[1]+vf];
            var target = [e.center[0]-uf, e.center[1]-vf];

            var side1 = [source[0]*0.75, source[1]*0.75];
            var side2 = [e.center[0], e.center[1]-vf];

            var color = mag > 0.2 ? "red" : "blue" ;
            var feature = {"type":"Feature","geometry":{"type":"LineString","coordinates":[source,target]},"options":{"opacity":mag*20.0,"color":color,"zoom":z}}
            flowLines.push(feature)

            //flowLines[i] = feature;
         }
      })
      //console.log(flowLines.length+" "+z);
      return flowLines;
}

function make_temps(locations) {
      console.log("making flow for time "+time_idx+" "+normed_zoom);
      var z = normed_zoom * 5 + 2;
      var idx = time_idx % 72;
      var c = 0;
      locations.forEach(function(e,i,a) {
         if ((idx % 2 == 0 && i % 2 == 1)
            || (idx % 2 == 1 && i % 2 == 0)) {
         
         var num = e.temp.length;
         c += 1;
         
         var t = e.temp[idx];;

         var s1 = [e.center[0]+3, e.center[1]];
         var s2 = [e.center[0]+3, e.center[1]+3];
         var s3 = [e.center[0], e.center[1]+3];
         var s4 = [e.center[0], e.center[1]];

         h = (1.0 - (t+1.8 / 36)) * 240
         var color = "hsla(" + h + ", 100%, 50%)";
         color = t > 30 ? "red" : t > 25 ? "orange" : t > 20 ? "yellow" : t > 15 ? "green" : "blue";
         //var feature = {"type":"Feature","geometry":{"type":"LineString","coordinates":[s1,s2,s3,s4]},"options":{"opacity":0.5,"color":d3.hsl(color),"zoom":z}}
         var feature = {"type":"Feature","geometry":{"type":"Point","coordinates":e.center},"options":{"opacity":0.5,"color":color,"zoom":z*3}}

         tempspots[i] = feature;
         }
      })
      console.log(tempspots.length+" "+c);
      return tempspots;
}
function flying_arc(pts) {
   var source = pts.source,
       target = pts.target;

   var mid = location_along_arc(source, target, .5);
   var result = [ proj(source),
       sky(mid),
       proj(target) ]
   return result;
}

function flow_vector(pts) {
   var zonal = pts.uf,
       medial= pts.vf;

   //var mid = location_along_arc(source, target, .5);
   var result = [ proj(source),
       sky(mid),
       proj(target) ]
   return result;
}

function refresh(bool) {
      /*
   svg.selectAll(".point").attr("d", path)
      .attr("opacity", function(d) {
            return fade_at_edge(d)
            });
            */

   if (bool) {
      // new data
      var f = make_flows(flow);
      var t = make_temps(celcius);

      svg.select(".currents")
         .selectAll("path").data(f)
         .enter().append("path")
         .attr("class","flows")
         .attr("d", path)

      svg.select(".heat")
         .selectAll("path").data(t)
         .enter().append("path")
         .attr("class","temperature")
         .attr("d", path)
   }
   svg.selectAll(".land").attr("d", path);
   svg.selectAll("circle").attr("r", proj.scale());

   svg.selectAll("marker")
      .attr("markerHeight", 1.0*normed_zoom+3.0)
      .attr("markerWidth", 1.0*normed_zoom+2.0)
      //.selectAll("path").data(f)
      //.enter().append("path")
      //.style("fill", function(d) { return d.options.color;});

   //svg.selectAll("marker").attr("fill", "Blue");


      /*
   svg.selectAll(".flows").attr("d", path);
      .attr("opacity", function(d) {
         return fade_at_edge(d)
         });
         // TODO looks nice but is processor intensive
         */

   svg.selectAll(".temperature").attr("d", path)

   svg.selectAll(".flows").attr("d",path)
         .style("stroke", function(d) { return d.options.color;})
         .style("stroke-width", function(d) { return d.options.zoom;})
   svg.selectAll(".temperature").attr("d",path)
         .style("stroke", function(d) { return d.options.color;})
         .style("fill", function(d) { return d.options.color;})
         .style("stroke-width", function(d) { return d.options.zoom;})
      //.selectAll("marker-end")
      //.style("fill", function(d) { return d.options.color;})
}

function fade_at_edge(d) {
   var centerPos = proj.invert([width/2,height/2]),
       arc = d3.geo.greatArc(),
       start, end;
   // function is called on 2 different data structures..
   if (d.source) {
      start = d.source, 
            end = d.target;  
   }
   else {
      start = d.geometry.coordinates[0];
      end = d.geometry.coordinates[1];
   }

   var start_dist = 1.57 - arc.distance({source: start, target: centerPos}),
       end_dist = 1.57 - arc.distance({source: end, target: centerPos});

   var fade = d3.scale.linear().domain([-.1,0]).range([0,.1]) 
      var dist = start_dist < end_dist ? start_dist : end_dist; 

   return fade(dist)
}

function location_along_arc(start, end, loc) {
   var interpolator = d3.geo.interpolate(start,end);
   return interpolator(loc)
}

// modified from http://bl.ocks.org/1392560
var m0, o0, z0;
function mousedown() {
   m0 = [d3.event.pageX, d3.event.pageY];
   o0 = proj.rotate();
   d3.event.preventDefault();
}
function mousemove() {
   if (m0) {
      var m1 = [d3.event.pageX, d3.event.pageY]
         , o1 = [o0[0] + (m1[0] - m0[0]) / 6, o0[1] + (m0[1] - m1[1]) / 6];
      o1[1] = o1[1] > 45 ? 45 :
         o1[1] < -45 ? -45 :
         o1[1];
      proj.rotate(o1);
      sky.rotate(o1);
      refresh(0);
   }
}
function mouseup() {
   if (m0) {
      mousemove();
      m0 = null;
   }
}
function zoomStart() {
   z0 = d3.event.scale;
}

function zoomed() {
   normed_zoom = d3.event.scale - 1.0;
   var s1 = Math.round((proj_zoom[1]-proj_zoom[0])*normed_zoom+ proj_zoom[0]);
   var s2 = Math.round((sky_zoom[1]-sky_zoom[0])*normed_zoom + sky_zoom[0]);

   proj.scale(s1);
   sky.scale(s1);
   refresh(0);
}

function zoomEnd() {

}
   </script>
</body>

